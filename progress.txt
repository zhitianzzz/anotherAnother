// The Hand Capture
let handpose;
let predictions = [];
let img;
// load the image before the main program starts
function preload(){
  img = loadImage("data/hand.jpg");
}
function setup() {
  // Create a canvas that's at least the size of the image.
  createCanvas(400, 350);
  // call modelReady() when it is loaded
  handpose = ml5.handpose(modelReady);
  frameRate(1); // set the frameRate to 1 since we don't need it to be running quickly in this case
}
// when poseNet is ready, do the detection
function modelReady() {
  console.log("Model ready!");
 
  // when the predict function is called, tell
  // handpose what to do with the results.
  // in this case we assign the results to our global
  // predictions variable
  handpose.on("predict", results => {
    predictions = results;
  });
  handpose.predict(img);
}
// draw() will not show anything until poses are found
function draw() {
  if (predictions.length > 0) {
    image(img, 0, 0, width, height);
    drawKeypoints();
    noLoop(); // stop looping when the poses are estimated
  }
}
// A function to draw ellipses over the detected keypoints
function drawKeypoints() {
  for (let i = 0; i < predictions.length; i += 1) {
    const prediction = predictions[i];
    for (let j = 0; j < prediction.landmarks.length; j += 1) {
      const keypoint = prediction.landmarks[j];
      fill(0, 255, 0);
      noStroke();
      ellipse(keypoint[0], keypoint[1], 10, 10);
    }
  }
}

//UPDATE 01
let vehicles = [];
let optimaFont;

function preload() {
  optimaFont = loadFont('OptimaMedium.ttf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(32);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.".toUpperCase();
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let linePoints = optimaFont.textToPoints(line, 50, 200 + yOffset, 32, {
      sampleFactor: 0.5
    });
    points = points.concat(linePoints);
    yOffset += 40; // leading
  }

  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);
  }
}

function draw() {
  background(0);
  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.update();
    v.show();
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.r = 1; // SIZE of each particle
    this.maxspeed = 10;
    this.maxforce = 1;
  }

  behaviors() {
    let arrive = this.arrive(this.target);
    this.applyForce(arrive);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxforce);
    return steer;
  }

  update() {
    this.pos.add(this.vel);
    this.vel.add(this.acc);
    this.acc.mult(0);
  }

  show() {
    stroke(255);
    strokeWeight(this.r);
    point(this.pos.x, this.pos.y);
  }
}

//Coded with Copilot
//Other references: text particle by jlee334
//https://editor.p5js.org/jlee334/sketches/resjxVski 


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//UPDATE 02

let vehicles = [];
let optimaFont;

function preload() {
  optimaFont = loadFont('OptimaMedium.ttf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.".toUpperCase();
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    //For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, 200 + yOffset, 64, { 
      sampleFactor: 0.15 // For the number of particles, same as textSize
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add random particles for each character
    for (let j = 0; j < 5; j++) { // For the NUMBER of particles
      // For offset particles
      let offsetX = random(-5, 5);
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }
}

function draw() {
  background(0);
  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.update();
    v.show();
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.r = 1.5; // SIZE of each particle
    this.maxspeed = 10;
    this.maxforce = 1;
  }

  behaviors() {
    let arrive = this.arrive(this.target);
    this.applyForce(arrive);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxforce);
    return steer;
  }

  update() {
    this.pos.add(this.vel);
    this.vel.add(this.acc);
    this.acc.mult(0);
  }

  show() {
    stroke(255);
    strokeWeight(this.r);
    point(this.pos.x+10, this.pos.y+10, this.r*10);
  }
}

//Coded with Copilot
//Other references: text particle by jlee334
//https://editor.p5js.org/jlee334/sketches/resjxVski 

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//UPDATE 03
let optimaFont;
let handpose;
let video;
let predictions = [];

function preload() {
  optimaFont = loadFont('OptimaMedium.ttf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.".toUpperCase();
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, 200 + yOffset, 64, { 
      sampleFactor: 0.15 // For the number of particles, same as textSize
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add random particles for each character
    for (let j = 0; j < 5; j++) { // For the NUMBER of particles
      // For offset particles
      let offsetX = random(-5, 5);
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose
  video = createCapture(VIDEO);
  video.size(width, height);

  handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  handpose.on("predict", results => {
    predictions = results;
  });

  // Hide the video element, and just show the canvas
  video.hide();
}

function modelReady() {
  console.log("Model is working now :D");
}

// Create fingers as keypoints
function createFinger(name, points, color) {
  return {
    name: name,
    points: points,
    color: color
  };
}

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.update();
    v.show();
  }
}

function processKeypoints() {
  if (predictions.length > 0) {
    let prediction = predictions[0];
   
    // Add the points for each finger
    let fingers = [
      createFinger("thumb", prediction.annotations.thumb, 'red'),
      createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
      createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
      createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
      createFinger("pinky", prediction.annotations.pinky, 'purple')
    ];

    // Calculate the distance between the thumb and pinky finger
    let thumbTip = fingers[0].points[3]; // Thumb tip
    let pinkyTip = fingers[4].points[3]; // Pinky tip

    let distance = dist(thumbTip[0], thumbTip[1], pinkyTip[0], pinkyTip[1]);
    console.log("Distance between thumb and pinky:", distance);
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.r = 1.5; // SIZE of each particle
    this.maxspeed = 10;
    this.maxforce = 1;
  }

  behaviors() {
    let arrive = this.arrive(this.target);
    this.applyForce(arrive);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxforce);
    return steer;
  }

  update() {
    this.pos.add(this.vel);
    this.vel.add(this.acc);
    this.acc.mult(0);
  }

  show() {
    stroke(255);
    strokeWeight(this.r);
    point(this.pos.x, this.pos.y);
  }
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//UPDATE 04
let vehicles = [];
let optimaFont;
let handpose;
let video;
let predictions = [];
let thumbPrevPos = null;
let thumbCurrPos = null;
let thumbSpeed = 0;
let canUpdateTextContent = true;

let textContent;
const para1 = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.";
const para2 = "The fridge moans,\nThe fan breathes deeply,\nInhales the dusty, heavy air.\nSighs…";
const para3 = "There are no signs of the morning,\nDarkness as creamy as soup.\nScrolling… scrolling…\nOne window faces the car park,\nUp… and up…\nAnother kisses a concrete wall.";
const para4 = "Here you are,\nDragging your bones into the toilet.\nHumidity climbs the mouldy air,\nSoaking up the small space,\nClogging your lungs.\nA pale palm turns off the tap.";
const para5 = "You know,\nIt is another start.";
const para6 = "Then,\nLike a bouncy ball,\nYou bump into all kinds of corners,\nCrashing into the world.";
const para7 = "Restless, unsettled at first—\nYou soon loosen up and surrender,\nSpinning and spinning…\nLose yourself in the washing machine,\nUntil you are drained completely.";
const para8 = "You were let go,\nReleased into your cell.";
const para9 = "You have missed\nthe remnant of sunlight.\nThey walk past your room\nat 3:30 in the afternoon,\nLingering for only 30 minutes\nUntil they are invited\nto the glass tower next street.";
const para10 = "As a pity...\nThey left behind a stripe of warmth,\nSmeared across your desk—\nBut you missed that too.\nPerhaps you saw it\nIn the corner of your eye,\nBut turned away.";
const para11 = "12 AM.\nYou feel like you’ve done nothing,\nAnd the fluorescent glow whispers\nIt’s another day.";

// Initialize textContent with the first paragraph
textContent = para1.toUpperCase();



function preload() {
  optimaFont = loadFont('OptimaMedium.ttf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = para1.toUpperCase();
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset [USED FOR CENTERING THE TEXT]
  let yCenterOffset = (height - totalHeight) / 2 - 90;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, yCenterOffset + yOffset, 64, { 
      sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let offsetX = random(-5, 5); // Reduce the offset range
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose
  video = createCapture(VIDEO);
  video.size(width, height);

  handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  handpose.on("predict", results => {
    predictions = results;
  });

  // Hide the video element, and just show the canvas
  // video.hide();
}

function modelReady() {
  console.log("Model is working now :D");
}

// Create fingers as keypoints
function createFinger(name, points, color) {
  return {
    name: name,
    points: points,
    color: color
  };
}

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.update();
    v.show();
  }
}

function processKeypoints() {
  if (predictions.length > 0) {
    let prediction = predictions[0];
   
    // Add the points for each finger
    let fingers = [
      createFinger("thumb", prediction.annotations.thumb, 'red'),
      createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
      createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
      createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
      createFinger("pinky", prediction.annotations.pinky, 'purple')
    ];

    // Get the current position of the thumb tip
    thumbCurrPos = fingers[0].points[3]; // Thumb tip

    // Calculate the speed of the thumb
    if (thumbPrevPos) {
      let distance = dist(thumbPrevPos[0], thumbPrevPos[1], thumbCurrPos[0], thumbCurrPos[1]);
      thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
      console.log("Speed of the thumb:", thumbSpeed);

      // Check if the thumb is moving from right to left
      let isMovingRightToLeft = thumbPrevPos[0] > thumbCurrPos[0];

      // Calculate the distance between the thumb and pinky finger
      let pinkyTip = fingers[4].points[3]; // Pinky tip
      let thumbPinkyDistance = dist(thumbCurrPos[0], thumbCurrPos[1], pinkyTip[0], pinkyTip[1]);
      console.log("Distance between thumb and pinky:", thumbPinkyDistance);

      // Check conditions and update textContent
      if (thumbSpeed > 1000 && thumbPinkyDistance > 50 && isMovingRightToLeft) {
        if (textContent === para1.toUpperCase()) {
          textContent = para2.toUpperCase();
        } else if (textContent === para2.toUpperCase()) {
          textContent = para3.toUpperCase();
        } else if (textContent === para3.toUpperCase()) {
          textContent = para4.toUpperCase();
        } else if (textContent === para4.toUpperCase()) {
          textContent = para5.toUpperCase();
        } else if (textContent === para5.toUpperCase()) {
          textContent = para6.toUpperCase();
        } else if (textContent === para6.toUpperCase()) {
          textContent = para7.toUpperCase();
        } else if (textContent === para7.toUpperCase()) {
          textContent = para8.toUpperCase();
        } else if (textContent === para8.toUpperCase()) {
          textContent = para9.toUpperCase();
        } else if (textContent === para9.toUpperCase()) {
          textContent = para10.toUpperCase();
        } else if (textContent === para10.toUpperCase()) {
          textContent = para11.toUpperCase();
        } else if (textContent === para11.toUpperCase()) {
          textContent = para1.toUpperCase();
        }
        
        updateTextContent();
      }
    }

    // Update the previous position of the thumb
    thumbPrevPos = thumbCurrPos;
  }
}

class Vehicle {
  constructor(x, y) {
    // Initialize the position of the vehicle at a random location
    this.pos = createVector(random(width), random(height));
    // Set the target position for the vehicle
    this.target = createVector(x, y);
    // Initialize the velocity with a random 2D vector
    this.vel = p5.Vector.random2D();
    // Initialize the acceleration vector
    this.acc = createVector();
    // Radius of the vehicle (size of each particle)
    this.r = 1.5;
    // Maximum speed the vehicle can move
    this.maxspeed = 10;
    // Maximum force that can be applied to the vehicle
    this.maxforce = 0.7;
  }

  // Method to handle the behaviors of the vehicle
  behaviors() {
    // Calculate the force to arrive at the target
    let arrive = this.arrive(this.target);
    // Calculate the force to seek the target
    let seek = this.seek(this.target);
    // Apply the arrive force
    this.applyForce(arrive);
    // Apply the seek force
    this.applyForce(seek);
  }

  // Method to apply a force to the vehicle
  applyForce(f) {
    this.acc.add(f);
  }

  // Method to calculate the force needed to arrive at the target
  arrive(target) {
    // Calculate the desired vector from the current position to the target
    let desired = p5.Vector.sub(target, this.pos);
    // Calculate the distance to the target
    let d = desired.mag();
    // Set the speed based on the distance (slows down as it approaches the target)
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    // Set the magnitude of the desired vector to the calculated speed
    desired.setMag(speed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to calculate the force needed to seek the target
  seek(target) {
    // Calculate the desired vector from the current position to the target
    let desired = p5.Vector.sub(target, this.pos);
    // Set the magnitude of the desired vector to the maximum speed
    desired.setMag(this.maxspeed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to update the position of the vehicle
  update() {
    // Update the velocity based on the acceleration
    this.vel.add(this.acc);
    // Update the position based on the velocity
    this.pos.add(this.vel);
    // Reset the acceleration to 0
    this.acc.mult(0);
  }

  // Method to display the vehicle
  show() {
    // Set the stroke color to white
    stroke(255);
    // Set the stroke weight to the radius of the vehicle
    strokeWeight(this.r);
    // Draw a point at the current position of the vehicle
    point(this.pos.x, this.pos.y);
  }
}

// Update the text content and create particles for each character
function updateTextContent() {
  if (!canUpdateTextContent) return;

  // Avoiding multiple updates in a short time
  canUpdateTextContent = false;
  setTimeout(() => {
    canUpdateTextContent = true;
  }, 2000);

  vehicles = [];
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset to center the text block
  let yCenterOffset = (height - totalHeight) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, yCenterOffset + yOffset, 64, { 
      sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let offsetX = random(-5, 5); // Reduce the offset range
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }
}

//Coded with Copilot
//Other references: 
//text particle by jlee334: https://editor.p5js.org/jlee334/sketches/resjxVski 
//ml5js-fingertipsinhats-webcam by vyasakanksha: https://editor.p5js.org/vyasakanksha/sketches/4-E2ThsHY/

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//UPDATE 05
let vehicles = [];
let optimaFont;
let handpose;
let video;
let predictions = [];
let thumbPrevPos = null;
let thumbCurrPos = null;
let thumbSpeed = 0;
let canUpdateTextContent = true;

let textContent;
const para1 = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.";
const para2 = "The fridge moans,\nThe fan breathes deeply,\nInhales the dusty, heavy air.\nSighs…";
const para3 = "There are no signs of the morning,\nDarkness as creamy as soup.\nScrolling… scrolling…\nOne window faces the car park,\nUp… and up…\nAnother kisses a concrete wall.";
const para4 = "Here you are,\nDragging your bones into the toilet.\nHumidity climbs the mouldy air,\nSoaking up the small space,\nClogging your lungs.\nA pale palm turns off the tap.";
const para5 = "You know,\nIt is another start.";
const para6 = "Then,\nLike a bouncy ball,\nYou bump into all kinds of corners,\nCrashing into the world.";
const para7 = "Restless, unsettled at first—\nYou soon loosen up and surrender,\nSpinning and spinning…\nLose yourself in the washing machine,\nUntil you are drained completely.";
const para8 = "You were let go,\nReleased into your cell.";
const para9 = "You have missed\nthe remnant of sunlight.\nThey walk past your room\nat 3:30 in the afternoon,\nLingering for only 30 minutes\nUntil they are invited\nto the glass tower next street.";
const para10 = "As a pity...\nThey left behind a stripe of warmth,\nSmeared across your desk—\nBut you missed that too.\nPerhaps you saw it\nIn the corner of your eye,\nBut turned away.";
const para11 = "12 AM.\nYou feel like you’ve done nothing,\nAnd the fluorescent glow whispers\nIt’s another day.";

// Initialize textContent with the first paragraph
textContent = para1.toUpperCase();



function preload() {
  optimaFont = loadFont('OptimaMedium.ttf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = para1.toUpperCase();
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset [USED FOR CENTERING THE TEXT]
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, yCenterOffset + yOffset, 64, { 
      sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let offsetX = random(-5, 5); // Reduce the offset range
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose
  video = createCapture(VIDEO);
  video.size(windowWidth, windowHeight);

  handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  handpose.on("predict", results => {
    predictions = results;
  });

  // Hide the video element below, just show the canvas
  video.hide();
}

function modelReady() {
  console.log("Model is working now :D");
}

// Create fingers as keypoints
function createFinger(name, points, color) {
  return {
    name: name,
    points: points,
    color: color
  };
}

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.seekMouse();
    v.update();
    v.show();
  }
}

function processKeypoints() {
  if (predictions.length > 0) {
    let prediction = predictions[0];
   
    // Add the points for each finger
    let fingers = [
      createFinger("thumb", prediction.annotations.thumb, 'red'),
      createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
      createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
      createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
      createFinger("pinky", prediction.annotations.pinky, 'purple')
    ];

    // Draw the keypoints
    // for (let i = 0; i < fingers.length; i += 1) {
    //   let finger = fingers[i];
    //   fill(finger.color);
    //   noStroke();
    //   ellipse(finger.points[3][0], finger.points[3][1], 10, 10);
    // }

    // Get the current position of the thumb tip
    thumbCurrPos = fingers[0].points[3]; // Thumb tip

    // Calculate the speed of the thumb
    if (thumbPrevPos) {
      let distance = dist(thumbPrevPos[0], thumbPrevPos[1], thumbCurrPos[0], thumbCurrPos[1]);
      thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
      console.log("Speed of the thumb:", thumbSpeed);

      // Check if the thumb is moving from right to left
      let isMovingRightToLeft = thumbPrevPos[0] > thumbCurrPos[0];

      // Calculate the distance between the thumb and pinky finger
      let pinkyTip = fingers[4].points[3]; // Pinky tip
      let thumbPinkyDistance = dist(thumbCurrPos[0], thumbCurrPos[1], pinkyTip[0], pinkyTip[1]);
      console.log("Distance between thumb and pinky:", thumbPinkyDistance);

      // Check conditions and update textContent
      if (thumbSpeed > 1000 && thumbPinkyDistance > 100 && isMovingRightToLeft) {
        if (textContent === para1.toUpperCase()) {
          textContent = para2.toUpperCase();
        } else if (textContent === para2.toUpperCase()) {
          textContent = para3.toUpperCase();
        } else if (textContent === para3.toUpperCase()) {
          textContent = para4.toUpperCase();
        } else if (textContent === para4.toUpperCase()) {
          textContent = para5.toUpperCase();
        } else if (textContent === para5.toUpperCase()) {
          textContent = para6.toUpperCase();
        } else if (textContent === para6.toUpperCase()) {
          textContent = para7.toUpperCase();
        } else if (textContent === para7.toUpperCase()) {
          textContent = para8.toUpperCase();
        } else if (textContent === para8.toUpperCase()) {
          textContent = para9.toUpperCase();
        } else if (textContent === para9.toUpperCase()) {
          textContent = para10.toUpperCase();
        } else if (textContent === para10.toUpperCase()) {
          textContent = para11.toUpperCase();
        } else if (textContent === para11.toUpperCase()) {
          textContent = para1.toUpperCase();
        }
        
        updateTextContent();
      }
    }

    // Update the previous position of the thumb
    thumbPrevPos = thumbCurrPos;
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    // Radius/size of each particle
    this.r = 1.5;
    this.maxspeed = 10;
    this.maxforce = 1;
    this.speed = 0;
  }

  // Method to handle the behaviors of the vehicle
  behaviors() {
    let arrive = this.arrive(this.target);
    let seek = this.seek(this.target);
    this.applyForce(arrive);
    this.applyForce(seek);
  }

  // Method to apply a force to the vehicle
  applyForce(force) {
    this.acc.add(force);
  }

  // Calculate the force needed to arrive at the target
  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    // Slows down as it approaches the target)
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    // Set the magnitude of the desired vector to the calculated speed
    desired.setMag(speed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to calculate the force needed to seek the target
  seek(target) {
    let desired = p5.Vector.sub(target, this.pos);
    // Set the magnitude of the desired vector to the maximum speed
    desired.setMag(this.maxspeed);
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Update the position of the vehicle
  update() {
    // Update the velocity based on the acceleration
    this.vel.add(this.acc);
    // Update the position based on the velocity
    this.pos.add(this.vel);
    // Reset acc to 0
    this.acc.mult(0);
    this.speed = this.vel.mag(); 
  }

  // Method to display the vehicle
  show() {
    stroke(255);
    strokeWeight(map(this.speed, 0, this.maxspeed, 1.3, 0.3)); 
    point(this.pos.x, this.pos.y);
  }

  seekMouse() {
    let mouse = createVector(mouseX, mouseY);
    let seekForce = this.seek(mouse);
    this.applyForce(seekForce);
  }
}

// Update the text content and create particles for each character
function updateTextContent() {
  if (!canUpdateTextContent) return;

  // Avoiding multiple updates in a short time
  canUpdateTextContent = false;
  setTimeout(() => {
    canUpdateTextContent = true;
  }, 2000);

  vehicles = [];
  let points = [];

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset to center the text block
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // For the font size for the particle text
    let linePoints = optimaFont.textToPoints(line, 50, yCenterOffset + yOffset, 64, { 
      sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
    });
    points = points.concat(linePoints);
    yOffset += 90; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let offsetX = random(-5, 5); // Reduce the offset range
      let offsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + offsetX, pt.y + offsetY);
      vehicles.push(vehicle);
    }
  }
}

//Coded with Copilot
//Other references: 
//text particle by jlee334: https://editor.p5js.org/jlee334/sketches/resjxVski 
//ml5js-fingertipsinhats-webcam by vyasakanksha: https://editor.p5js.org/vyasakanksha/sketches/4-E2ThsHY/


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// UPDATE 06
let vehicles = [];
let optimaFont;
let handpose;
let video;
let hands = [];

let thumbPrevPos = null;
let thumbCurrPos = null;
let thumbSpeed = 0;
let canUpdateTextContent = true;
let thumbPinkyDistance = 0;
let textContent = "";

const para1 = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.";
const para2 = "The fridge moans,\nThe fan breathes deeply,\nInhales the dusty, heavy air.\nSighs…";
const para3 = "There are no signs of the morning,\nDarkness as creamy as soup.\nScrolling… scrolling…\nOne window faces the car park,\nUp… and up…\nAnother kisses a concrete wall.";
const para4 = "Here you are,\nDragging your bones into the toilet.\nHumidity climbs the mouldy air,\nSoaking up the small space,\nClogging your lungs.\nA pale palm turns off the tap.";
const para5 = "You know,\nIt is another start.";
const para6 = "Then,\nLike a bouncy ball,\nYou bump into all kinds of corners,\nCrashing into the world.";
const para7 = "Restless, unsettled at first—\nYou soon loosen up and surrender,\nSpinning and spinning…\nLose yourself in the washing machine,\nUntil you are drained completely.";
const para8 = "You were let go,\nReleased into your cell.";
const para9 = "You have missed\nthe remnant of sunlight.\nThey walk past your room\nat 3:30 in the afternoon,\nLingering for only 30 minutes\nUntil they are invited\nto the glass tower next street.";
const para10 = "As a pity...\nThey left behind a stripe of warmth,\nSmeared across your desk—\nBut you missed that too.\nPerhaps you saw it\nIn the corner of your eye,\nBut turned away.";
const para11 = "12 AM.\nYou feel like you’ve done nothing,\nAnd the fluorescent glow whispers\nIt’s another day.";

// Initialize textContent with the first paragraph
textContent = para1.toUpperCase();

function preload() {
  optimaFont = loadFont('optimaMedium.ttf');
  handPose = ml5.handPose();
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = para1.toUpperCase();
  let points = [];

  // Tracking of the text
  let tracking = 1.8;

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset [USED FOR CENTERING THE TEXT]
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;

    // For the font size for the particle text
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 64, { 
        sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += 98; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-5, 5); // Reduce the offset range
      let dotsOffsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose v.1.0
  // video = createCapture(VIDEO);
  // video.size(width, height);
  
  //draw video capture feed as image inside p5 canvas
  // handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  // handpose.on("predict", results => {
  //   predictions = results;
  // });

  // Hide the video element below, just show the canvas
  // video.hide();

  // Setup handpose v.2.0
  push();
  video = createCapture(VIDEO);
  video.size(width, height);
  video.hide();

  handPose.detectStart(video, gotHands);
  pop();

  noCursor(); 
}

function modelReady() {
  console.log("Model is working now :D");
}

// Create fingers as keypoints
// function createFinger(name, points, color) {
//   return {
//     name: name,
//     points: points,
//     color: color
//   };
// }

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.seekMouse();
    v.update();
    v.show();
  }
}

// Callback function for when handPose outputs data
function gotHands(results) {
  // save the output to the hands variable
  hands = results;
}

function processKeypoints() {
  // if (predictions.length > 0) {
  //   let prediction = predictions[0];
   
  //   // Add the points for each finger
  //   let fingers = [
  //     createFinger("thumb", prediction.annotations.thumb, 'red'),
  //     createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
  //     createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
  //     createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
  //     createFinger("pinky", prediction.annotations.pinky, 'purple')
  //   ];

  //   // Draw the keypoints
  //   for (let i = 0; i < fingers.length; i += 1) {
  //     let finger = fingers[i];
  //     fill(finger.color);
  //     noStroke();
  //     ellipse(finger.points[3][0], finger.points[3][1], 10, 10);
  //   }

  //   // Get the current position of the thumb tip
  //   thumbCurrPos = fingers[0].points[3]; // Thumb tip

  //   // Calculate the speed of the thumb
  //   if (thumbPrevPos) {
  //     let distance = dist(thumbPrevPos[0], thumbPrevPos[1], thumbCurrPos[0], thumbCurrPos[1]);
  //     thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
  //     console.log("Speed of the thumb:", thumbSpeed);

  //     // Check if the thumb is moving from right to left
  //     let isMovingRightToLeft = thumbPrevPos[0] > thumbCurrPos[0];

  //     // Calculate the distance between the thumb and pinky finger
  //     let pinkyTip = fingers[4].points[3]; // Pinky tip
  //     let thumbPinkyDistance = dist(thumbCurrPos[0], thumbCurrPos[1], pinkyTip[0], pinkyTip[1]);
  //     console.log("Distance between thumb and pinky:", thumbPinkyDistance);

  //     // Check conditions and update textContent
  //     if (thumbSpeed > 1000 && thumbPinkyDistance > 100 && isMovingRightToLeft) {
  //       if (textContent === para1.toUpperCase()) {
  //         textContent = para2.toUpperCase();
  //       } else if (textContent === para2.toUpperCase()) {
  //         textContent = para3.toUpperCase();
  //       } else if (textContent === para3.toUpperCase()) {
  //         textContent = para4.toUpperCase();
  //       } else if (textContent === para4.toUpperCase()) {
  //         textContent = para5.toUpperCase();
  //       } else if (textContent === para5.toUpperCase()) {
  //         textContent = para6.toUpperCase();
  //       } else if (textContent === para6.toUpperCase()) {
  //         textContent = para7.toUpperCase();
  //       } else if (textContent === para7.toUpperCase()) {
  //         textContent = para8.toUpperCase();
  //       } else if (textContent === para8.toUpperCase()) {
  //         textContent = para9.toUpperCase();
  //       } else if (textContent === para9.toUpperCase()) {
  //         textContent = para10.toUpperCase();
  //       } else if (textContent === para10.toUpperCase()) {
  //         textContent = para11.toUpperCase();
  //       } else if (textContent === para11.toUpperCase()) {
  //         textContent = para1.toUpperCase();
  //       }
        
  //       updateTextContent();
  //     }
  //   }

  //   // Update the previous position of the thumb
  //   thumbPrevPos = thumbCurrPos;
  // }
  
  // Draw the fingertips and calculate thumb speed and distance to pinky
  for (let i = 0; i < hands.length; i++) {
    let hand = hands[i];
    let fingertipIndices = [4, 8, 12, 16, 20];
    let colors = ['red', 'green', 'blue', 'yellow', 'purple'];

    // for (let j = 0; j < fingertipIndices.length; j++) {
    //   let keypoint = hand.keypoints[fingertipIndices[j]];
    //   fill(colors[j]);
    //   noStroke();
    //   circle(width - keypoint.x, keypoint.y, 10);
    //   // text(fingertipIndices[j], width - keypoint.x + 20, keypoint.y - 20);
    // }

    // Get the current position of the thumb and pinky tips
    thumbCurrPos = hand.keypoints[4]; // Thumb tip
    let pinkyCurrPos = hand.keypoints[20]; // Pinky tip

    // Calculate the speed of the thumb
    if (thumbPrevPos) {
      let distance = dist(thumbPrevPos.x, thumbPrevPos.y, thumbCurrPos.x, thumbCurrPos.y);
      thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
      console.log("Speed of the thumb:", thumbSpeed);

      // Check if the thumb is moving from right to left
      let isMovingRightToLeft = thumbPrevPos.x > thumbCurrPos.x;

      // Calculate the distance between the thumb and pinky tips
      thumbPinkyDistance = dist(thumbCurrPos.x, thumbCurrPos.y, pinkyCurrPos.x, pinkyCurrPos.y);
      console.log("Distance between thumb and pinky:", thumbPinkyDistance);

      // Check conditions and update textContent
      if (thumbSpeed > 5000 && thumbPinkyDistance > 200 && isMovingRightToLeft) {
        if (textContent === para1.toUpperCase()) {
          textContent = para2.toUpperCase();
        } else if (textContent === para2.toUpperCase()) {
          textContent = para3.toUpperCase();
        } else if (textContent === para3.toUpperCase()) {
          textContent = para4.toUpperCase();
        } else if (textContent === para4.toUpperCase()) {
          textContent = para5.toUpperCase();
        } else if (textContent === para5.toUpperCase()) {
          textContent = para6.toUpperCase();
        } else if (textContent === para6.toUpperCase()) {
          textContent = para7.toUpperCase();
        } else if (textContent === para7.toUpperCase()) {
          textContent = para8.toUpperCase();
        } else if (textContent === para8.toUpperCase()) {
          textContent = para9.toUpperCase();
        } else if (textContent === para9.toUpperCase()) {
          textContent = para10.toUpperCase();
        } else if (textContent === para10.toUpperCase()) {
          textContent = para11.toUpperCase();
        } else if (textContent === para11.toUpperCase()) {
          textContent = para1.toUpperCase();
        }
        
        updateTextContent();
      }
    }

    // Update the previous position of the thumb
    thumbPrevPos = thumbCurrPos;

        // Map the index finger to the mouse cursor
        let indexFingerPos = hand.keypoints[8]; // Index finger tip
        cursorX = width - indexFingerPos.x;
        cursorY = indexFingerPos.y;
    
        // Draw the cursor as a white circle
        fill(255);
        noStroke();
        circle(cursorX, cursorY, 20); // 20: diameter of the circle
      
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    // Radius/size of each particle
    this.r = 1.5;
    this.maxspeed = 10;
    this.maxforce = 1.5;
    this.speed = 0;
  }

  // Method to handle the behaviors of the vehicle
  behaviors() {
    let arrive = this.arrive(this.target);
    let seek = this.seek(this.target);
    this.applyForce(arrive);
    this.applyForce(seek);
  }

  // Method to apply a force to the vehicle
  applyForce(force) {
    this.acc.add(force);
  }

  // Calculate the force needed to arrive at the target
  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    // Slows down as it approaches the target)
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    // Set the magnitude of the desired vector to the calculated speed
    desired.setMag(speed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to calculate the force needed to seek the target
  seek(target) {
    let desired = p5.Vector.sub(target, this.pos);
    // Set the magnitude of the desired vector to the maximum speed
    desired.setMag(this.maxspeed);
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Update the position of the vehicle
  update() {
    // Update the velocity based on the acceleration
    this.vel.add(this.acc);
    // Update the position based on the velocity
    this.pos.add(this.vel);
    // Reset acc to 0
    this.acc.mult(0);
    this.speed = this.vel.mag(); 
  }

  // Method to display the vehicle
  show() {
    stroke(255);
    strokeWeight(map(this.speed, 0, this.maxspeed, 1.3, 0.3)); 
    point(this.pos.x, this.pos.y);
  }

  seekMouse() {
    let mouse = createVector(mouseX, mouseY);
    let seekForce = this.seek(mouse);
    this.applyForce(seekForce);
  }
}

// Update the text content and create particles for each character
function updateTextContent() {
  if (!canUpdateTextContent) return;

  // Avoiding multiple updates in a short time
  canUpdateTextContent = false;
  setTimeout(() => {
    canUpdateTextContent = true;
  }, 2000);

  vehicles = [];
  let points = [];

  // Tracking of the text
  let tracking = 1.8;

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset to center the text block
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;

    // For the font size for the particle text
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 64, { 
        sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += 98; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-5, 5); // Reduce the offset range
      let dotsOffsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }
}

//Coded with Copilot
//Other references: 
//text particle by jlee334: https://editor.p5js.org/jlee334/sketches/resjxVski 
//ml5js-fingertipsinhats-webcam by vyasakanksha: https://editor.p5js.org/vyasakanksha/sketches/4-E2ThsHY/

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// UPDATE 07
let vehicles = [];
let optimaFont;
let handpose;
let video;
// let predictions = [];
let hands = [];

let thumbPrevPos = null;
let thumbCurrPos = null;
let thumbSpeed = 0;
let canUpdateTextContent = true;
let thumbPinkyDistance = 0;
let textContent = "";

let cursorX, cursorY; 

const para1 = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.";
const para2 = "The fridge moans,\nThe fan breathes deeply,\nInhales the dusty, heavy air.\nSighs…";
const para3 = "There are no signs of the morning,\nDarkness as creamy as soup.\nScrolling… scrolling…\nOne window faces the car park,\nUp… and up…\nAnother kisses a concrete wall.";
const para4 = "Here you are,\nDragging your bones into the toilet.\nHumidity climbs the mouldy air,\nSoaking up the small space,\nClogging your lungs.\nA pale palm turns off the tap.";
const para5 = "You know,\nIt is another start.";
const para6 = "Then,\nLike a bouncy ball,\nYou bump into all kinds of corners,\nCrashing into the world.";
const para7 = "Restless, unsettled at first—\nYou soon loosen up and surrender,\nSpinning and spinning…\nLose yourself in the washing machine,\nUntil you are drained completely.";
const para8 = "You were let go,\nReleased into your cell.";
const para9 = "You have missed\nthe remnant of sunlight.\nThey walk past your room\nat 3:30 in the afternoon,\nLingering for only 30 minutes\nUntil they are invited\nto the glass tower next street.";
const para10 = "As a pity...\nThey left behind a stripe of warmth,\nSmeared across your desk—\nBut you missed that too.\nPerhaps you saw it\nIn the corner of your eye,\nBut turned away.";
const para11 = "12 AM.\nYou feel like you’ve done nothing,\nAnd the fluorescent glow whispers\nIt’s another day.";

// Initialize textContent with the first paragraph
textContent = para1.toUpperCase();

function preload() {
  optimaFont = loadFont('optimaMedium.ttf');
  handPose = ml5.handPose();
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(64);
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 

  let textContent = para1.toUpperCase();
  let points = [];

  // Tracking of the text
  let tracking = 1.8;

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset [USED FOR CENTERING THE TEXT]
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;

    // For the font size for the particle text
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 64, { 
        sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += 98; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-5, 5); // Reduce the offset range
      let dotsOffsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose v.1.0
  // video = createCapture(VIDEO);
  // video.size(width, height);
  
  //draw video capture feed as image inside p5 canvas
  // handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  // handpose.on("predict", results => {
  //   predictions = results;
  // });

  // Hide the video element below, just show the canvas
  // video.hide();

  // Setup handpose v.2.0
  push();
  video = createCapture(VIDEO);
  video.size(width, height);
  video.hide();

  handPose.detectStart(video, gotHands);
  pop();

  noCursor(); 
}

function modelReady() {
  console.log("Model is working now :D");
}

// Create fingers as keypoints
// function createFinger(name, points, color) {
//   return {
//     name: name,
//     points: points,
//     color: color
//   };
// }

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.seekMouse(cursorX, cursorY);
    v.update();
    v.show();
  }
}

// Callback function for when handPose outputs data
function gotHands(results) {
  // save the output to the hands variable
  hands = results;
}

function processKeypoints() {
  // if (predictions.length > 0) {
  //   let prediction = predictions[0];
   
  //   // Add the points for each finger
  //   let fingers = [
  //     createFinger("thumb", prediction.annotations.thumb, 'red'),
  //     createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
  //     createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
  //     createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
  //     createFinger("pinky", prediction.annotations.pinky, 'purple')
  //   ];

  //   // Draw the keypoints
  //   for (let i = 0; i < fingers.length; i += 1) {
  //     let finger = fingers[i];
  //     fill(finger.color);
  //     noStroke();
  //     ellipse(finger.points[3][0], finger.points[3][1], 10, 10);
  //   }

  //   // Get the current position of the thumb tip
  //   thumbCurrPos = fingers[0].points[3]; // Thumb tip

  //   // Calculate the speed of the thumb
  //   if (thumbPrevPos) {
  //     let distance = dist(thumbPrevPos[0], thumbPrevPos[1], thumbCurrPos[0], thumbCurrPos[1]);
  //     thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
  //     console.log("Speed of the thumb:", thumbSpeed);

  //     // Check if the thumb is moving from right to left
  //     let isMovingRightToLeft = thumbPrevPos[0] > thumbCurrPos[0];

  //     // Calculate the distance between the thumb and pinky finger
  //     let pinkyTip = fingers[4].points[3]; // Pinky tip
  //     let thumbPinkyDistance = dist(thumbCurrPos[0], thumbCurrPos[1], pinkyTip[0], pinkyTip[1]);
  //     console.log("Distance between thumb and pinky:", thumbPinkyDistance);

  //     // Check conditions and update textContent
  //     if (thumbSpeed > 1000 && thumbPinkyDistance > 100 && isMovingRightToLeft) {
  //       if (textContent === para1.toUpperCase()) {
  //         textContent = para2.toUpperCase();
  //       } else if (textContent === para2.toUpperCase()) {
  //         textContent = para3.toUpperCase();
  //       } else if (textContent === para3.toUpperCase()) {
  //         textContent = para4.toUpperCase();
  //       } else if (textContent === para4.toUpperCase()) {
  //         textContent = para5.toUpperCase();
  //       } else if (textContent === para5.toUpperCase()) {
  //         textContent = para6.toUpperCase();
  //       } else if (textContent === para6.toUpperCase()) {
  //         textContent = para7.toUpperCase();
  //       } else if (textContent === para7.toUpperCase()) {
  //         textContent = para8.toUpperCase();
  //       } else if (textContent === para8.toUpperCase()) {
  //         textContent = para9.toUpperCase();
  //       } else if (textContent === para9.toUpperCase()) {
  //         textContent = para10.toUpperCase();
  //       } else if (textContent === para10.toUpperCase()) {
  //         textContent = para11.toUpperCase();
  //       } else if (textContent === para11.toUpperCase()) {
  //         textContent = para1.toUpperCase();
  //       }
        
  //       updateTextContent();
  //     }
  //   }

  //   // Update the previous position of the thumb
  //   thumbPrevPos = thumbCurrPos;
  // }
  
  // Draw the fingertips and calculate thumb speed and distance to pinky
  for (let i = 0; i < hands.length; i++) {
    let hand = hands[i];

    // TEST FINGERTIP COLOR
    // let fingertipIndices = [4, 8, 12, 16, 20];
    // let colors = ['red', 'green', 'blue', 'yellow', 'purple'];

    // for (let j = 0; j < fingertipIndices.length; j++) {
    //   let keypoint = hand.keypoints[fingertipIndices[j]];
    //   fill(colors[j]);
    //   noStroke();
    //   circle(width - keypoint.x, keypoint.y, 10);
    //   // text(fingertipIndices[j], width - keypoint.x + 20, keypoint.y - 20);
    // }

    // Get the current position of the thumb and pinky tips
    thumbCurrPos = hand.keypoints[4]; // Thumb tip
    let pinkyCurrPos = hand.keypoints[20]; // Pinky tip

    // Calculate the speed of the thumb
    if (thumbPrevPos) {
      let distance = dist(thumbPrevPos.x, thumbPrevPos.y, thumbCurrPos.x, thumbCurrPos.y);
      thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
      console.log("Speed of the thumb:", thumbSpeed);

      // Check if the thumb is moving from right to left
      let isMovingRightToLeft = thumbPrevPos.x > thumbCurrPos.x;

      // Calculate the distance between the thumb and pinky tips
      thumbPinkyDistance = dist(thumbCurrPos.x, thumbCurrPos.y, pinkyCurrPos.x, pinkyCurrPos.y);
      console.log("Distance between thumb and pinky:", thumbPinkyDistance);

      // Check conditions and update textContent
      if (thumbSpeed > 5000 && thumbPinkyDistance > 200 && isMovingRightToLeft) {
        if (textContent === para1.toUpperCase()) {
          textContent = para2.toUpperCase();
        } else if (textContent === para2.toUpperCase()) {
          textContent = para3.toUpperCase();
        } else if (textContent === para3.toUpperCase()) {
          textContent = para4.toUpperCase();
        } else if (textContent === para4.toUpperCase()) {
          textContent = para5.toUpperCase();
        } else if (textContent === para5.toUpperCase()) {
          textContent = para6.toUpperCase();
        } else if (textContent === para6.toUpperCase()) {
          textContent = para7.toUpperCase();
        } else if (textContent === para7.toUpperCase()) {
          textContent = para8.toUpperCase();
        } else if (textContent === para8.toUpperCase()) {
          textContent = para9.toUpperCase();
        } else if (textContent === para9.toUpperCase()) {
          textContent = para10.toUpperCase();
        } else if (textContent === para10.toUpperCase()) {
          textContent = para11.toUpperCase();
        } else if (textContent === para11.toUpperCase()) {
          textContent = para1.toUpperCase();
        }
        
        updateTextContent();
      }
    }

    // Update the previous position of the thumb
    thumbPrevPos = thumbCurrPos;

        // Map the index finger to the mouse cursor
        let indexFingerPos = hand.keypoints[8]; 
        cursorX = width - indexFingerPos.x;
        cursorY = indexFingerPos.y;
    
        // Draw the cursor as a white circle
        fill(255);
        noStroke();
        circle(cursorX, cursorY, 10); // 20: diameter of the circle
      
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    // Radius/size of each particle
    this.r = 1.5;
    this.maxspeed = 10;
    this.maxforce = 1.5;
    this.speed = 0;
  }

  // Method to handle the behaviors of the vehicle
  behaviors() {
    let arrive = this.arrive(this.target);
    let seek = this.seek(this.target);
    this.applyForce(arrive);
    this.applyForce(seek);
  }

  // Method to apply a force to the vehicle
  applyForce(force) {
    this.acc.add(force);
  }

  // Calculate the force needed to arrive at the target
  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    // Slows down as it approaches the target)
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    // Set the magnitude of the desired vector to the calculated speed
    desired.setMag(speed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to calculate the force needed to seek the target
  seek(target) {
    let desired = p5.Vector.sub(target, this.pos);
    // Set the magnitude of the desired vector to the maximum speed
    desired.setMag(this.maxspeed);
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Update the position of the vehicle
  update() {
    // Update the velocity based on the acceleration
    this.vel.add(this.acc);
    // Update the position based on the velocity
    this.pos.add(this.vel);
    // Reset acc to 0
    this.acc.mult(0);
    this.speed = this.vel.mag(); 
  }

  // Method to display the vehicle
  show() {
    stroke(255);
    strokeWeight(map(this.speed, 0, this.maxspeed, 1.3, 0.3)); 
    point(this.pos.x, this.pos.y);
  }

  seekMouse(cursorX, cursorY) {
    let mouse = createVector(cursorX, cursorY);
    let seekForce = this.seek(mouse);
    this.applyForce(seekForce);
  }
}

// Update the text content and create particles for each character
function updateTextContent() {
  if (!canUpdateTextContent) return;

  // Avoiding multiple updates in a short time
  canUpdateTextContent = false;
  setTimeout(() => {
    canUpdateTextContent = true;
  }, 2000);

  vehicles = [];
  let points = [];

  // Tracking of the text
  let tracking = 1.8;

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * 90; // Calculate total height of the text block

  // Calculate the vertical offset to center the text block
  let yCenterOffset = (windowHeight - totalHeight + 90) / 2;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;

    // For the font size for the particle text
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 64, { 
        sampleFactor: 0.13 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += 98; // For leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);

    // Add fewer random particles for each character
    for (let j = 0; j < 2; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-5, 5); // Reduce the offset range
      let dotsOffsetY = random(-5, 5); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }
}

//Coded with Copilot
//Other references: 
//text particle by jlee334: https://editor.p5js.org/jlee334/sketches/resjxVski 
//ml5js-fingertipsinhats-webcam by vyasakanksha: https://editor.p5js.org/vyasakanksha/sketches/4-E2ThsHY/

//
// UPDATE 08
let vehicles = [];
let optimaFont;
let handpose;
let video;
// let predictions = [];
let hands = [];

let thumbPrevPos = null;
let thumbCurrPos = null;
let thumbSpeed = 0;
let canUpdateTextContent = true;
let thumbPinkyDistance = 0;
let textContent = "";

let cursorX, cursorY; 
let trailX, trailY; 
let easing = 0.23;
let showCursor = false;

const para1 = "Here you are,\nLying in this six-foot-long bed,\nWondering if you’ll ever wake\nFrom this dream of being alive\nOr if you’ll just keep on sleeping.";
const para2 = "The fridge moans,\nThe fan breathes deeply,\nInhales the dusty, heavy air.\nSighs…";
const para3 = "There are no signs of the morning,\nDarkness as creamy as soup.\nScrolling… scrolling…\nOne window faces the car park,\nUp… and up…\nAnother kisses a concrete wall.";
const para4 = "Here you are,\nDragging your bones into the toilet.\nHumidity climbs the mouldy air,\nSoaking up the small space,\nClogging your lungs.\nA pale palm turns off the tap.";
const para5 = "You know,\nIt is another start.";
const para6 = "Then,\nLike a bouncy ball,\nYou bump into all kinds of corners,\nCrashing into the world.";
const para7 = "Restless, unsettled at first—\nYou soon loosen up and surrender,\nSpinning and spinning…\nLose yourself in the washing machine,\nUntil you are drained completely.";
const para8 = "You were let go,\nReleased into your cell.";
const para9 = "You have missed\nthe remnant of sunlight.\nThey walk past your room\nat 3:30 in the afternoon,\nLingering for only 30 minutes\nUntil they are invited\nto the glass tower next street.";
const para10 = "As a pity...\nThey left behind a stripe of warmth,\nSmeared across your desk—\nBut you missed that too.\nPerhaps you saw it\nIn the corner of your eye,\nBut turned away.";
const para11 = "12 AM.\nYou feel like you’ve done nothing,\nAnd the fluorescent glow whispers\nIt’s another day.";

// Initialize textContent with the first paragraph
textContent = para1.toUpperCase();

function preload() {
  optimaFont = loadFont('optimaMedium.ttf');
  handPose = ml5.handPose();
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  textSize(52); // Font size
  textAlign(LEFT, CENTER);
  textFont(optimaFont); 
  let textContent = para1.toUpperCase();
  let points = [];
  let tracking = 4; // Tracking in pixels
  let leading = 70; // Leading in pixels

  // Split the text into lines and create points for each line
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * leading; // Calculate total height of the text block
  let yCenterOffset = (windowHeight - totalHeight + leading) / 2; // Calculate the vertical offset for centering the text

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 52, { 
        sampleFactor: 0.2 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += leading; // Adjust yOffset for leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);
    for (let j = 0; j < 1; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-4, 4); 
      let dotsOffsetY = random(-4, 4); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }

  // Setup handpose v.1.0
  // video = createCapture(VIDEO);
  // video.size(width, height);
  
  //draw video capture feed as image inside p5 canvas
  // handpose = ml5.handpose(video, modelReady);

  // This sets up an event that fills the global variable "predictions"
  // with an array every time new hand poses are detected
  // handpose.on("predict", results => {
  //   predictions = results;
  // });

  // Hide the video element below, just show the canvas
  // video.hide();

  // Setup handpose v.2.0
  push();
  video = createCapture(VIDEO);
  video.size(width, height);
  video.hide();

  handPose.detectStart(video, gotHands);
  pop();

  // frameRate(70);
  noCursor(); 
  trailX = width / 2; 
  trailY = height / 2;
}

// function modelReady() {
//   console.log("Model is working now :D");
// }

// Create fingers as keypoints
// function createFinger(name, points, color) {
//   return {
//     name: name,
//     points: points,
//     color: color
//   };
// }

function draw() {
  background(0);

  // Process keypoints without drawing them
  processKeypoints();

  for (let i = 0; i < vehicles.length; i++) {
    let v = vehicles[i];
    v.behaviors();
    v.seekMouse(cursorX, cursorY);
    v.update();
    v.show();
  }
}

// Callback function for when handPose outputs data
function gotHands(results) {
  // save the output to the hands variable
  hands = results;
}

function processKeypoints() {
  // if (predictions.length > 0) {
  //   let prediction = predictions[0];
   
  //   // Add the points for each finger
  //   let fingers = [
  //     createFinger("thumb", prediction.annotations.thumb, 'red'),
  //     createFinger("indexFinger", prediction.annotations.indexFinger, 'green'),
  //     createFinger("middleFinger", prediction.annotations.middleFinger, 'blue'),
  //     createFinger("ringFinger", prediction.annotations.ringFinger, 'yellow'),
  //     createFinger("pinky", prediction.annotations.pinky, 'purple')
  //   ];

  //   // Draw the keypoints
  //   for (let i = 0; i < fingers.length; i += 1) {
  //     let finger = fingers[i];
  //     fill(finger.color);
  //     noStroke();
  //     ellipse(finger.points[3][0], finger.points[3][1], 10, 10);
  //   }

  //   // Get the current position of the thumb tip
  //   thumbCurrPos = fingers[0].points[3]; // Thumb tip

  //   // Calculate the speed of the thumb
  //   if (thumbPrevPos) {
  //     let distance = dist(thumbPrevPos[0], thumbPrevPos[1], thumbCurrPos[0], thumbCurrPos[1]);
  //     thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
  //     console.log("Speed of the thumb:", thumbSpeed);

  //     // Check if the thumb is moving from right to left
  //     let isMovingRightToLeft = thumbPrevPos[0] > thumbCurrPos[0];

  //     // Calculate the distance between the thumb and pinky finger
  //     let pinkyTip = fingers[4].points[3]; // Pinky tip
  //     let thumbPinkyDistance = dist(thumbCurrPos[0], thumbCurrPos[1], pinkyTip[0], pinkyTip[1]);
  //     console.log("Distance between thumb and pinky:", thumbPinkyDistance);

  //     // Check conditions and update textContent
  //     if (thumbSpeed > 1000 && thumbPinkyDistance > 100 && isMovingRightToLeft) {
  //       if (textContent === para1.toUpperCase()) {
  //         textContent = para2.toUpperCase();
  //       } else if (textContent === para2.toUpperCase()) {
  //         textContent = para3.toUpperCase();
  //       } else if (textContent === para3.toUpperCase()) {
  //         textContent = para4.toUpperCase();
  //       } else if (textContent === para4.toUpperCase()) {
  //         textContent = para5.toUpperCase();
  //       } else if (textContent === para5.toUpperCase()) {
  //         textContent = para6.toUpperCase();
  //       } else if (textContent === para6.toUpperCase()) {
  //         textContent = para7.toUpperCase();
  //       } else if (textContent === para7.toUpperCase()) {
  //         textContent = para8.toUpperCase();
  //       } else if (textContent === para8.toUpperCase()) {
  //         textContent = para9.toUpperCase();
  //       } else if (textContent === para9.toUpperCase()) {
  //         textContent = para10.toUpperCase();
  //       } else if (textContent === para10.toUpperCase()) {
  //         textContent = para11.toUpperCase();
  //       } else if (textContent === para11.toUpperCase()) {
  //         textContent = para1.toUpperCase();
  //       }
        
  //       updateTextContent();
  //     }
  //   }

  //   // Update the previous position of the thumb
  //   thumbPrevPos = thumbCurrPos;
  // }
  
  // Draw the fingertips and calculate thumb speed and distance to pinky
  for (let i = 0; i < hands.length; i++) {
    let hand = hands[i];

    // TEST FINGERTIP COLOR
    // let fingertipIndices = [4, 8, 12, 16, 20];
    // let colors = ['red', 'green', 'blue', 'yellow', 'purple'];

    // for (let j = 0; j < fingertipIndices.length; j++) {
    //   let keypoint = hand.keypoints[fingertipIndices[j]];
    //   fill(colors[j]);
    //   noStroke();
    //   circle(width - keypoint.x, keypoint.y, 10);
    //   // text(fingertipIndices[j], width - keypoint.x + 20, keypoint.y - 20);
    // }

    // Get the current position of the thumb and pinky tips
    thumbCurrPos = hand.keypoints[4]; // Thumb tip
    let pinkyCurrPos = hand.keypoints[20]; // Pinky tip

    // Calculate the speed of the thumb
    if (thumbPrevPos) {
      let distance = dist(thumbPrevPos.x, thumbPrevPos.y, thumbCurrPos.x, thumbCurrPos.y);
      thumbSpeed = distance / (1 / frameRate()); // Speed = distance / time
      // console.log("Speed of the thumb:", thumbSpeed);

      // Check if the thumb is moving from right to left
      let isMovingRightToLeft = thumbPrevPos.x > thumbCurrPos.x;

      // Calculate the distance between the thumb tip and the index finger tip
      let thumbTip = hand.keypoints[4]; 
      let indexTip = hand.keypoints[8]; 
      let pinchDistance = dist(thumbTip.x, thumbTip.y, indexTip.x, indexTip.y);
    
      // console.log("Pinch Distance is: " + pinchDistance);

      // Show the cursor only if the fingers are pinched together
      showCursor = pinchDistance < 50; 

      // Calculate the distance between the thumb and pinky tips
      // thumbPinkyDistance = dist(thumbCurrPos.x, thumbCurrPos.y, pinkyCurrPos.x, pinkyCurrPos.y);
      // console.log("Distance between thumb and pinky:", thumbPinkyDistance);

      // Check conditions and update textContent
      if (thumbSpeed > 5000 && pinchDistance > 50 && isMovingRightToLeft) {
        if (textContent === para1.toUpperCase()) {
          textContent = para2.toUpperCase();
        } else if (textContent === para2.toUpperCase()) {
          textContent = para3.toUpperCase();
        } else if (textContent === para3.toUpperCase()) {
          textContent = para4.toUpperCase();
        } else if (textContent === para4.toUpperCase()) {
          textContent = para5.toUpperCase();
        } else if (textContent === para5.toUpperCase()) {
          textContent = para6.toUpperCase();
        } else if (textContent === para6.toUpperCase()) {
          textContent = para7.toUpperCase();
        } else if (textContent === para7.toUpperCase()) {
          textContent = para8.toUpperCase();
        } else if (textContent === para8.toUpperCase()) {
          textContent = para9.toUpperCase();
        } else if (textContent === para9.toUpperCase()) {
          textContent = para10.toUpperCase();
        } else if (textContent === para10.toUpperCase()) {
          textContent = para11.toUpperCase();
        } else if (textContent === para11.toUpperCase()) {
          textContent = para1.toUpperCase();
        }
        updateTextContent();
      }
    }

    // Update the previous position of the thumb
    thumbPrevPos = thumbCurrPos;

    // Map the index finger to the mouse cursor
    let indexFingerPos = hand.keypoints[8]; 
    cursorX = width - indexFingerPos.x;
    cursorY = indexFingerPos.y;
    
        if (showCursor) {
        // Trailing circle
        fill(255, 127);
        noStroke();
        ellipse(trailX, trailY, 30, 30);

        // Update trailing circle
        let dx = cursorX - trailX;
        let dy = cursorY - trailY;
        trailX += dx * easing;
        trailY += dy * easing;

        // Actual cursor
        // fill(255);
        // noStroke();
        // ellipse(cursorX, cursorY, 10); 
        }
  }
}

class Vehicle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    // Radius/size of each particle
    this.r = 0.8;
    this.maxspeed = 10;
    this.maxforce = 2;
    this.speed = 1.2;
  }

  // Method to handle the behaviors of the vehicle
  behaviors() {
    let arrive = this.arrive(this.target);
    let seek = this.seek(this.target);
    this.applyForce(arrive);
    this.applyForce(seek);
  }

  // Method to apply a force to the vehicle
  applyForce(force) {
    this.acc.add(force);
  }

  // Calculate the force needed to arrive at the target
  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    // Slows down as it approaches the target)
    let speed = this.maxspeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxspeed);
    }
    // Set the magnitude of the desired vector to the calculated speed
    desired.setMag(speed);
    // Calculate the steering force
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Method to calculate the force needed to seek the target
  seek(target) {
    let desired = p5.Vector.sub(target, this.pos);
    // Set the magnitude of the desired vector to the maximum speed
    desired.setMag(this.maxspeed);
    let steer = p5.Vector.sub(desired, this.vel);
    // Limit the steering force to the maximum force
    steer.limit(this.maxforce);
    return steer;
  }

  // Update the position of the vehicle
  update() {
    // Update the velocity based on the acceleration
    this.vel.add(this.acc);
    // Update the position based on the velocity
    this.pos.add(this.vel);
    // Reset acc to 0
    this.acc.mult(0);
    this.speed = this.vel.mag(); 
  }

  // Animation: how the particles form together
  show() {
    stroke(255);
    strokeWeight(map(this.speed, 0, this.maxspeed, 1.3, 0.01)); 
    point(this.pos.x, this.pos.y);
  }

  seekMouse(cursorX, cursorY) {
    let mouse = createVector(cursorX, cursorY);
    let seekForce = this.seek(mouse);
    this.applyForce(seekForce);
  }
}

// Update the text content and create particles for each character
function updateTextContent() {
  if (!canUpdateTextContent) return;

  // Avoiding multiple updates in a short time
  canUpdateTextContent = false;
  setTimeout(() => {
    canUpdateTextContent = true;
  }, 2000);

  vehicles = [];
  let points = [];
  let tracking = 4; // Tracking in pixels
  let leading = 70; // Leading in pixels

  // Split text
  let lines = textContent.split('\n');
  let yOffset = 0;
  let totalHeight = lines.length * leading; // Total height of text block
  let yCenterOffset = (windowHeight - totalHeight + leading) / 2; // Vertical offset for centering

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let xOffset = 2;
    for (let j = 0; j < line.length; j++) {
      let char = line[j];
      let charPoints = optimaFont.textToPoints(char, 50 + xOffset, yCenterOffset + yOffset, 52, { 
        sampleFactor: 0.2 // Increase sampleFactor to reduce the number of particles
      });
      points = points.concat(charPoints);
      xOffset += textWidth(char) + tracking; // Adjust xOffset for tracking
    }
    yOffset += leading; // Adjust yOffset for leading
  }

  // Add more particles for each character
  for (let i = 0; i < points.length; i++) {
    let pt = points[i];
    let vehicle = new Vehicle(pt.x, pt.y);
    vehicles.push(vehicle);
    for (let j = 0; j < 1; j++) { // Reduce the number of additional particles
      let dotsOffsetX = random(-4, 4); 
      let dotsOffsetY = random(-4, 4); 
      let vehicle = new Vehicle(pt.x + dotsOffsetX, pt.y + dotsOffsetY);
      vehicles.push(vehicle);
    }
  }
}

//Coded with Copilot
//Other references: 
//text particle by jlee334: https://editor.p5js.org/jlee334/sketches/resjxVski 
//ml5js-fingertipsinhats-webcam by vyasakanksha: https://editor.p5js.org/vyasakanksha/sketches/4-E2ThsHY/